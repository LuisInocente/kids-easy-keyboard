<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Noten Player</title>

<style>
:root{
  --ink:#111827;
  --card:#f8fafc;
  --border:rgba(0,0,0,.10);
  --accent:#ef4444;
  --muted:#6b7280;
}
*{box-sizing:border-box}
body{
  margin:0;
  padding:16px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:#fff;
  color:var(--ink);
}
.wrap{max-width:1150px;margin:0 auto}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:14px;
  padding:12px;
  box-shadow:0 8px 24px rgba(0,0,0,.06);
}
.controls{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:nowrap;
  overflow:hidden;
}
button{
  height:34px;
  padding:0 10px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#fff;
  font-weight:800;
  font-size:13px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:8px;
  line-height:1;
  color:var(--ink);
  -webkit-tap-highlight-color:transparent;
  appearance:none;
  user-select:none;
  outline:none;
  flex:0 0 auto;
  transition:transform .04s ease, box-shadow .08s ease, filter .08s ease;
}
button:hover{ box-shadow:0 2px 6px rgba(0,0,0,.08); }
button:active{
  transform:translateY(1px);
  box-shadow:inset 0 3px 6px rgba(0,0,0,.18);
}
button.primary{background:var(--ink);color:#fff;border:none}
button.primary:hover,
button.primary:focus,
button.primary:focus-visible{
  background:var(--ink);
  color:#fff;
}
button.primary:active{
  background:var(--ink);
  color:#fff;
  transform:translateY(1px);
  box-shadow:inset 0 3px 8px rgba(0,0,0,.35);
}
button.danger{background:#fff;border:1px solid rgba(239,68,68,.35)}
button.kbdDown{
  transform:translateY(1px);
  box-shadow:inset 0 3px 6px rgba(0,0,0,.18);
  filter:brightness(.98);
}
.small{
  font-size:12px;
  color:var(--muted);
  font-weight:800;
  white-space:nowrap;
  flex:0 0 auto;
}
input[type=range]{width:120px;flex:0 0 auto}
select, input[type=text]{
  height:34px;
  padding:0 8px;
  border-radius:10px;
  border:1px solid var(--border);
  font-weight:800;
  font-size:13px;
  background:#fff;
  color:var(--ink);
  flex:0 0 auto;
}
input[type=text]{ width:150px; }
.iconBox{
  width:18px;height:18px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  flex:0 0 18px;
}
.playIcon{font-size:16px}
.stopSquare{
  width:14px;
  height:14px;
  background:currentColor;
  border-radius:3px;
}
.stage{
  overflow:auto;
  margin-top:10px;
  -webkit-overflow-scrolling:touch;
  border-radius:12px;
}
.staff{stroke:#111827;stroke-width:2;stroke-linecap:round}
.bar{stroke:#111827;stroke-width:2}
.noteHead{fill:#111827}
.stem{stroke:#111827;stroke-width:2;stroke-linecap:round}
.label{font:17px system-ui;font-weight:900;text-anchor:middle}
.playhead{stroke:var(--accent);stroke-width:4;stroke-linecap:round}
.restGlyph{
  fill:#111827;
  text-anchor:middle;
  dominant-baseline:middle;
  font-family:
    "Bravura","Noto Music","Noto Music Symbols",
    "Segoe UI Symbol","Symbola","Arial Unicode MS",sans-serif;
  font-size:34px;
}
#status{
  min-width:90px;
  max-width:110px;
  overflow:hidden;
  text-overflow:ellipsis;
}
#playlist{ min-width:170px !important; }
</style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <div class="controls">
      <button id="playBtn" class="primary">
        <span class="iconBox"><span class="playIcon">‚ñ∂</span></span>
        Play
      </button>

      <button id="stopBtn">
        <span class="iconBox"><span class="stopSquare"></span></span>
        Stop
      </button>

      <button id="clearBtn" class="danger">Clear</button>

      <span class="small">Tempo</span>
      <input id="tempo" type="range" min="60" max="160" value="96">
      <span id="tempoVal" class="small">96</span>

      <select id="bars">
        <option value="4" selected>4</option>
        <option value="8">8</option>
        <option value="16">16</option>
      </select>
      <span class="small">maten</span>

      <input id="songName" type="text" placeholder="Naam" autocomplete="off" />
      <button id="saveBtn">Save</button>
      <button id="exportBtn">Export</button>

      <button id="importBtn">Load</button>
      <input id="importFile" type="file" accept=".json,application/json" hidden>

      <span class="small">Playlist</span>
      <select id="playlist"></select>
      <button id="deleteBtn" class="danger">Delete</button>

      <span id="status" class="small"></span>
    </div>

    <div class="stage" id="stage">
      <svg id="svg" width="980" height="270"></svg>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const NOTE_TO_MIDI={C:60,D:62,E:64,F:65,G:67,A:69,B:71};
const BW={
  C:"#e11d48",D:"#f97316",E:"#facc15",
  F:"#8ed265",G:"#008a8c",
  A:"#7c3aed",B:"#ec4899"
};
const STORAGE_KEY="notenPlayer_playlist_v1";

/* STAFF */
const STAFF_TOP=52, STAFF_LEFT=40, LINE_GAP=14, STAFF_LINES=5;

/* spacing tuned so you typically see ~4‚Äì5 bars */
const NOTE_GAP=60;
const NOTE_R=6.5;
const STEM_H=36;
const STEM_X_NUDGE=0.4;

/* ‚úÖ PLAYBACK SCROLL: show NEXT 4‚Äì5 bars (chunk scroll) */
const BEATS_PER_BAR = 4;
const STEP_BARS     = 4;
const LEFT_PAD_FRAC = 0.08;

/* ‚úÖ NOTE-ENTRY SCROLL (NEW):
   keep the new note visible, but only scroll when it would go off-screen */
const ENTRY_RIGHT_GUARD = 0.86; // if note passes 86% of viewport -> scroll
const ENTRY_LEFT_GUARD  = 0.10; // if note is left of 10% -> scroll back
const ENTRY_ANCHOR      = 0.70; // after scroll, place note around 70% (nice lookahead)

/* =========================
   STATE
========================= */
let SONG=[];
let bars=4;

const stage=document.getElementById("stage");
const svg=document.getElementById("svg");

const tempoEl=document.getElementById("tempo");
const tempoVal=document.getElementById("tempoVal");
const barsEl=document.getElementById("bars");

const playBtn=document.getElementById("playBtn");
const stopBtn=document.getElementById("stopBtn");
const clearBtn=document.getElementById("clearBtn");

const songNameEl=document.getElementById("songName");
const saveBtn=document.getElementById("saveBtn");
const exportBtn=document.getElementById("exportBtn");
const importBtn=document.getElementById("importBtn");
const importFile=document.getElementById("importFile");

const playlistEl=document.getElementById("playlist");
const deleteBtn=document.getElementById("deleteBtn");
const statusEl=document.getElementById("status");

function maxItems(){ return bars*4; }

/* =========================
   AUDIO
========================= */
let ctx=null, master=null;
let activeNodes=new Set();
const MASTER_LEVEL=.35;
const DRUM_LEVEL=1.35;

function ensureAudio(){
  if(!ctx){
    ctx=new (window.AudioContext||window.webkitAudioContext)();
    master=ctx.createGain();
    master.gain.value=MASTER_LEVEL;
    master.connect(ctx.destination);
  }
  if(ctx.state==="suspended") ctx.resume();
}
function freq(m){return 440*Math.pow(2,(m-69)/12)}

/* melody tone */
function playTone(m,t,d){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="triangle";
  o.frequency.setValueAtTime(freq(m),t);

  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.85,t+.01);
  g.gain.exponentialRampToValueAtTime(.0001,t+d-.02);

  o.connect(g); g.connect(master);
  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+d);
}
function blip(m){
  ensureAudio();
  playTone(m,ctx.currentTime+.01,.18);
}

/* count-in click */
function clickAt(t,high){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="square";
  o.frequency.setValueAtTime(high?2200:1400,t);
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.22*DRUM_LEVEL,t+.002);
  g.gain.exponentialRampToValueAtTime(.0001,t+.045);
  o.connect(g); g.connect(master);

  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+.05);
}

/* DRUMS */
function drumKick(t){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="sine";
  o.frequency.setValueAtTime(120,t);
  o.frequency.exponentialRampToValueAtTime(55,t+.08);

  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.55*DRUM_LEVEL,t+.004);
  g.gain.exponentialRampToValueAtTime(.0001,t+.12);

  o.connect(g); g.connect(master);
  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+.13);
}
function drumSnare(t){
  const noise=ctx.createBufferSource();
  const buf=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.12), ctx.sampleRate);
  const data=buf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
  noise.buffer=buf;

  const hp=ctx.createBiquadFilter();
  hp.type="highpass"; hp.frequency.setValueAtTime(1200,t);

  const g=ctx.createGain();
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.28*DRUM_LEVEL,t+.003);
  g.gain.exponentialRampToValueAtTime(.0001,t+.10);

  noise.connect(hp); hp.connect(g); g.connect(master);

  activeNodes.add(noise); activeNodes.add(hp); activeNodes.add(g);
  noise.onended=()=>{ activeNodes.delete(noise); activeNodes.delete(hp); activeNodes.delete(g); };

  noise.start(t); noise.stop(t+.11);
}
function drumHat(t){
  const noise=ctx.createBufferSource();
  const buf=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.03), ctx.sampleRate);
  const data=buf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
  noise.buffer=buf;

  const bp=ctx.createBiquadFilter();
  bp.type="bandpass"; bp.frequency.setValueAtTime(9000,t); bp.Q.setValueAtTime(6,t);

  const g=ctx.createGain();
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.12*DRUM_LEVEL,t+.0015);
  g.gain.exponentialRampToValueAtTime(.0001,t+.028);

  noise.connect(bp); bp.connect(g); g.connect(master);

  activeNodes.add(noise); activeNodes.add(bp); activeNodes.add(g);
  noise.onended=()=>{ activeNodes.delete(noise); activeNodes.delete(bp); activeNodes.delete(g); };

  noise.start(t); noise.stop(t+.03);
}
function scheduleDrums(startTime, beatDur, totalBeats){
  const totalHatSteps=totalBeats*2;
  for(let s=0;s<totalHatSteps;s++){
    const t=startTime + (s*(beatDur/2));
    drumHat(t);
  }
  for(let b=0;b<totalBeats;b++){
    const t=startTime + b*beatDur;
    const pos=b%4;
    if(pos===0 || pos===2) drumKick(t);
    if(pos===1 || pos===3) drumSnare(t);
  }
}

/* pitch ‚Üí y */
function pcToLetter(pc){return [0,0,1,1,2,3,3,4,4,5,5,6][pc]}
function yPos(m){
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;
  const oct=Math.floor(m/12)-1;
  const abs=oct*7+pcToLetter(m%12);
  const ref=4*7+2;
  return bottom-(abs-ref)*(LINE_GAP/2);
}

/* SVG helpers */
function clearSvg(){while(svg.firstChild)svg.removeChild(svg.firstChild)}
function L(x1,y1,x2,y2,c){
  const l=document.createElementNS("http://www.w3.org/2000/svg","line");
  l.setAttribute("x1",x1);l.setAttribute("y1",y1);
  l.setAttribute("x2",x2);l.setAttribute("y2",y2);
  if(c)l.setAttribute("class",c);
  return l;
}
function E(cx,cy,rx,ry,c){
  const e=document.createElementNS("http://www.w3.org/2000/svg","ellipse");
  e.setAttribute("cx",cx);e.setAttribute("cy",cy);
  e.setAttribute("rx",rx);e.setAttribute("ry",ry);
  if(c)e.setAttribute("class",c);
  return e;
}
function T(x,y,s,c,f){
  const t=document.createElementNS("http://www.w3.org/2000/svg","text");
  t.setAttribute("x",x);t.setAttribute("y",y);
  if(c)t.setAttribute("class",c);
  if(f)t.setAttribute("fill",f);
  t.textContent=s;
  return t;
}

/* playhead + scroll */
let noteX=[], playhead=null;
let lastWindowStartBar = -1;

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function scrollToWindowStartBar(windowStartBar){
  const startIndex = windowStartBar * BEATS_PER_BAR;
  const x = noteX[startIndex] ?? STAFF_LEFT;

  const vw = Math.max(1, stage.clientWidth);
  const maxScroll = Math.max(0, stage.scrollWidth - stage.clientWidth);

  const target = x - vw*LEFT_PAD_FRAC;
  stage.scrollLeft = clamp(target, 0, maxScroll);
}

function updateWindowByIndex(i){
  const bar = Math.floor(i / BEATS_PER_BAR);
  const windowStartBar = Math.floor(bar / STEP_BARS) * STEP_BARS;

  if(windowStartBar !== lastWindowStartBar){
    lastWindowStartBar = windowStartBar;
    scrollToWindowStartBar(windowStartBar);
  }
}

/* ‚úÖ NOTE ENTRY REVEAL: keep last entered note visible */
function revealIndexIfNeeded(i){
  if(i<0 || i>=noteX.length) return;

  const x = noteX[i];
  const vw = Math.max(1, stage.clientWidth);
  const maxScroll = Math.max(0, stage.scrollWidth - stage.clientWidth);
  const left = stage.scrollLeft;

  const leftGuard  = left + vw*ENTRY_LEFT_GUARD;
  const rightGuard = left + vw*ENTRY_RIGHT_GUARD;

  // only move if the note is about to go out of view
  if(x > rightGuard || x < leftGuard){
    const target = x - vw*ENTRY_ANCHOR;
    stage.scrollLeft = clamp(target, 0, maxScroll);
  }
}

function setPlayhead(i){
  if(!playhead || i<0 || i>=noteX.length){
    if(playhead) playhead.setAttribute("visibility","hidden");
    return;
  }
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;
  const x=noteX[i];
  playhead.setAttribute("x1",x);
  playhead.setAttribute("x2",x);
  playhead.setAttribute("y1",STAFF_TOP-26);
  playhead.setAttribute("y2",bottom+26);
  playhead.setAttribute("visibility","visible");

  // playback: chunk scroll on bar starts
  if(isPlaying && (i % BEATS_PER_BAR === 0)){
    updateWindowByIndex(i);
  }
}

/* render */
function render(){
  clearSvg(); noteX=[];
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;

  for(let i=0;i<STAFF_LINES;i++)
    svg.appendChild(L(STAFF_LEFT,STAFF_TOP+i*LINE_GAP,4000,STAFF_TOP+i*LINE_GAP,"staff"));

  playhead=L(STAFF_LEFT,STAFF_TOP-26,STAFF_LEFT,bottom+26,"playhead");
  playhead.setAttribute("visibility","hidden");
  svg.appendChild(playhead);

  let x=STAFF_LEFT+30, beats=0;
  SONG.forEach((it,i)=>{
    if(beats>0 && beats%4===0)
      svg.appendChild(L(x-12,STAFF_TOP,x-12,bottom,"bar"));

    if(it.type==="note"){
      const y=yPos(it.pitch);
      svg.appendChild(E(x,y,NOTE_R+1,NOTE_R,"noteHead"));
      if(it.pitch===60) svg.appendChild(L(x-14,y,x+14,y,"staff"));
      const sx=x+NOTE_R-STEM_X_NUDGE;
      svg.appendChild(L(sx,y,sx,y-STEM_H,"stem"));

      const n=Object.keys(NOTE_TO_MIDI).find(k=>NOTE_TO_MIDI[k]%12===it.pitch%12);
      svg.appendChild(T(x, bottom+46, n, "label", BW[n]||"#111827"));
    }else{
      svg.appendChild(T(x,STAFF_TOP+LINE_GAP*2,"ùÑΩ","restGlyph"));
    }

    noteX[i]=x;
    beats++;
    x+=NOTE_GAP;
  });

  svg.setAttribute("width",Math.max(980,x+40));
}

/* playback (loop until stop) */
let isPlaying=false, timers=[];
function stop(){
  isPlaying=false;
  timers.forEach(clearTimeout); timers=[];
  setPlayhead(-1);
  lastWindowStartBar=-1;

  if(ctx && master){
    const now=ctx.currentTime;
    master.gain.setTargetAtTime(.0001,now,.01);
    activeNodes.forEach(n=>{
      try{ if(typeof n.stop==="function") n.stop(now); }catch{}
    });
    activeNodes.clear();
    setTimeout(()=>{ if(master) master.gain.value=MASTER_LEVEL; },40);
  }
}

/* keyboard visual feedback */
let spaceHeld=false;
function setPlayVisual(down){ playBtn.classList.toggle("kbdDown", down); }
function setStopVisual(down){ stopBtn.classList.toggle("kbdDown", down); }

function scheduleLoop(startTime){
  if(!isPlaying) return;

  const beat = 60/tempoEl.value;
  let t = startTime;

  scheduleDrums(t, beat, SONG.length);

  SONG.forEach((it,i)=>{
    if(it.type==="note") playTone(it.pitch,t,beat);
    timers.push(setTimeout(()=>{ if(isPlaying) setPlayhead(i); }, (t-ctx.currentTime)*1000));
    t += beat;
  });

  timers.push(setTimeout(()=>{
    if(isPlaying){
      stage.scrollLeft = 0;
      lastWindowStartBar=-1;
      scheduleLoop(t);
    }
  }, (t-ctx.currentTime)*1000));
}

function play(){
  if(!SONG.length) return;

  ensureAudio();
  stop();
  isPlaying=true;

  const beat=60/tempoEl.value;
  let t=ctx.currentTime+.12;

  stage.scrollLeft=0;
  lastWindowStartBar=-1;

  scheduleDrums(t, beat, 4);
  for(let i=0;i<4;i++) clickAt(t + i*beat, i===0);

  t = t + 4*beat;

  updateWindowByIndex(0);
  scheduleLoop(t);
}

/* =========================
   INPUT (‚úÖ now reveals new notes)
========================= */
function afterEditReveal(){
  // keep playhead hidden while editing
  if(playhead) playhead.setAttribute("visibility","hidden");
  // reveal the last note/rest you just entered (only if needed)
  revealIndexIfNeeded(SONG.length-1);
}

function addNote(n,hi){
  if(SONG.length>=maxItems()) return;
  const p=NOTE_TO_MIDI[n]+(hi?12:0);
  SONG.push({type:"note",pitch:p});
  render();
  afterEditReveal();
  blip(p);
}
function addRest(){
  if(SONG.length>=maxItems()) return;
  SONG.push({type:"rest"});
  render();
  afterEditReveal();
}
function delLast(){
  SONG.pop();
  render();
  // reveal new last item (so you keep context)
  afterEditReveal();
}

function isTypingTarget(el){
  return el && (el.tagName==="INPUT" || el.tagName==="TEXTAREA" || el.isContentEditable);
}
window.addEventListener("keydown",(e)=>{
  if(isTypingTarget(document.activeElement)){
    if(e.code==="Escape"){ e.preventDefault(); stop(); }
    return;
  }

  if(e.code==="Space"){
    e.preventDefault();
    if(!spaceHeld){
      spaceHeld=true;
      if(isPlaying){
        setStopVisual(true);
        stop();
        setTimeout(()=>setStopVisual(false), 120);
      }else{
        setPlayVisual(true);
        play();
        setTimeout(()=>setPlayVisual(false), 120);
      }
    }
    return;
  }

  if(e.key==="Backspace"){ e.preventDefault(); delLast(); return; }
  if(e.key==="/"){ addRest(); return; }
  const k=e.key.toUpperCase();
  if(NOTE_TO_MIDI[k]) addNote(k, e.shiftKey);
},{passive:false});

window.addEventListener("keyup",(e)=>{
  if(e.code==="Space"){
    spaceHeld=false;
    setPlayVisual(false);
    setStopVisual(false);
  }
});

/* playlist */
function readPlaylist(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    const arr=raw?JSON.parse(raw):[];
    return Array.isArray(arr)?arr:[];
  }catch{ return []; }
}
function writePlaylist(arr){ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
function refreshPlaylistUI(selectName=null){
  const list=readPlaylist().sort((a,b)=>a.name.localeCompare(b.name));
  playlistEl.innerHTML="";
  if(!list.length){
    const opt=document.createElement("option");
    opt.value=""; opt.textContent="(leeg)";
    playlistEl.appendChild(opt);
    return;
  }
  list.forEach(item=>{
    const opt=document.createElement("option");
    opt.value=item.name;
    opt.textContent=item.name;
    playlistEl.appendChild(opt);
  });
  if(selectName){
    const found=[...playlistEl.options].some(o=>o.value===selectName);
    if(found) playlistEl.value=selectName;
  }
}
function setStatus(msg){
  statusEl.textContent=msg||"";
  if(msg) setTimeout(()=>{ if(statusEl.textContent===msg) statusEl.textContent=""; }, 2500);
}
function saveCurrent(){
  const name=(songNameEl.value||"").trim();
  if(!name){ setStatus("Geef een naam."); songNameEl.focus(); return; }
  const entry={ name, bars, song: SONG.slice(0, maxItems()) };
  const list=readPlaylist();
  const idx=list.findIndex(x=>x.name===name);
  if(idx>=0) list[idx]=entry; else list.push(entry);
  writePlaylist(list);
  refreshPlaylistUI(name);
  setStatus("Saved ‚úÖ");
}
function loadByName(name){
  const list=readPlaylist();
  const item=list.find(x=>x.name===name);
  if(!item) return;

  stop();
  bars=item.bars||4;
  barsEl.value=String(bars);
  SONG=Array.isArray(item.song)?item.song.slice(0, bars*4):[];
  songNameEl.value=item.name||"";
  render();
  stage.scrollLeft=0;
  setStatus("Loaded ‚úÖ");
}
function deleteSelected(){
  const name=playlistEl.value;
  if(!name) return;
  const list=readPlaylist().filter(x=>x.name!==name);
  writePlaylist(list);
  refreshPlaylistUI();
  setStatus("Deleted üóëÔ∏è");
}

/* export / load file */
function safeFileName(s){
  return (s||"song").trim().replace(/[\\\/:*?"<>|]+/g,"-").slice(0,80) || "song";
}
function exportCurrent(){
  const name=(songNameEl.value||"").trim() || "song";
  const payload={app:"noten-player",version:1,name,bars,tempo:+tempoEl.value,song:SONG.slice(0, maxItems())};
  const blob=new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download=`${safeFileName(name)}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 400);
  setStatus("Exported ‚¨áÔ∏è");
}
function importFromObject(obj){
  if(!obj || typeof obj!=="object") throw new Error("Ongeldig bestand.");
  if(!Array.isArray(obj.song)) throw new Error("Geen song gevonden.");
  const newBars=(obj.bars===4||obj.bars===8||obj.bars===16)?obj.bars:4;

  stop();
  bars=newBars;
  barsEl.value=String(bars);

  SONG=obj.song.slice(0,bars*4).map(it=>{
    if(it && it.type==="rest") return {type:"rest"};
    if(it && it.type==="note" && Number.isFinite(it.pitch)) return {type:"note",pitch:+it.pitch};
    return null;
  }).filter(Boolean);

  if(typeof obj.name==="string") songNameEl.value=obj.name.trim();
  if(Number.isFinite(obj.tempo)){
    const t=Math.max(+tempoEl.min, Math.min(+tempoEl.max, +obj.tempo));
    tempoEl.value=String(t); tempoVal.textContent=String(t);
  }
  render();
  stage.scrollLeft=0;
  setStatus("Loaded ‚úÖ");
}
function handleImportFile(file){
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{ importFromObject(JSON.parse(String(reader.result||""))); }
    catch{ setStatus("Load mislukt."); }
    importFile.value="";
  };
  reader.readAsText(file);
}

/* UI wiring */
tempoVal.textContent=tempoEl.value;
tempoEl.oninput=()=>tempoVal.textContent=tempoEl.value;

barsEl.value=String(bars);
barsEl.onchange=()=>{
  bars=+barsEl.value;
  if(SONG.length>maxItems()) SONG=SONG.slice(0,maxItems());
  render();
  // keep current view; if you were near the end, still ensure last note is visible
  afterEditReveal();
};

playBtn.onclick=()=>{
  setPlayVisual(true);
  play();
  setTimeout(()=>setPlayVisual(false), 120);
};
stopBtn.onclick=()=>{
  setStopVisual(true);
  stop();
  setTimeout(()=>setStopVisual(false), 120);
};

clearBtn.onclick=()=>{
  stop();
  SONG=[];
  render();
  stage.scrollLeft=0;
  setStatus("Cleared");
};

saveBtn.onclick=saveCurrent;
exportBtn.onclick=exportCurrent;

importBtn.onclick=()=>importFile.click();
importFile.onchange=()=>handleImportFile(importFile.files && importFile.files[0]);

deleteBtn.onclick=deleteSelected;

songNameEl.addEventListener("keydown",(e)=>{
  if(e.key==="Enter"){ e.preventDefault(); saveCurrent(); }
});

playlistEl.onchange=()=>{
  const name=playlistEl.value;
  if(name) loadByName(name);
};

refreshPlaylistUI();
render();

/* keep window positioning correct after resize */
window.addEventListener("resize", ()=>{
  if(isPlaying && lastWindowStartBar>=0){
    scrollToWindowStartBar(lastWindowStartBar);
  }else{
    // editing: keep last entered note visible
    revealIndexIfNeeded(SONG.length-1);
  }
});
</script>
</body>
</html>
