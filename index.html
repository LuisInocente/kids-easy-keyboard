<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Noten Player</title>

<style>
:root{
  --ink:#111827;
  --card:#f8fafc;
  --border:rgba(0,0,0,.10);
  --accent:#ef4444;
  --muted:#6b7280;
}
*{box-sizing:border-box}
body{
  margin:0;
  padding:16px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:#fff;
  color:var(--ink);
}
.wrap{max-width:1500px;margin:0 auto}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:18px;
  padding:14px;
  box-shadow:0 10px 30px rgba(0,0,0,.07);
}

/* ======= CONTROLS (2 rows) ======= */
.controls{
  display:flex;
  gap:12px;
  row-gap:12px;
  align-items:center;
  flex-wrap:wrap;     /* ‚úÖ wrap to 2nd row */
  overflow:visible;   /* ‚úÖ never clip */
}

button{
  height:52px;
  padding:0 16px;
  border-radius:16px;
  border:1px solid var(--border);
  background:#fff;
  font-weight:900;
  font-size:18px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:10px;
  line-height:1;
  color:var(--ink);
  -webkit-tap-highlight-color:transparent;
  appearance:none;
  user-select:none;
  outline:none;
  flex:0 0 auto;
  transition:transform .04s ease, box-shadow .08s ease, filter .08s ease;
}
button:hover{ box-shadow:0 4px 12px rgba(0,0,0,.10); }
button:active{
  transform:translateY(1px);
  box-shadow:inset 0 6px 14px rgba(0,0,0,.18);
}
button.primary{background:var(--ink);color:#fff;border:none}
button.primary:active{ box-shadow:inset 0 8px 18px rgba(0,0,0,.35); }
button.danger{border-color:rgba(239,68,68,.40)}
button.kbdDown{
  transform:translateY(1px);
  box-shadow:inset 0 6px 14px rgba(0,0,0,.18);
  filter:brightness(.98);
}

.small{
  font-size:16px;
  color:var(--muted);
  font-weight:900;
  white-space:nowrap;
  flex:0 0 auto;
}
input[type=range]{width:220px;flex:0 0 auto}
select, input[type=text]{
  height:52px;
  padding:0 12px;
  border-radius:16px;
  border:1px solid var(--border);
  font-weight:900;
  font-size:18px;
  background:#fff;
  color:var(--ink);
  flex:0 0 auto;
}
input[type=text]{ width:230px; }

/* icons */
.iconBox{
  width:26px;height:26px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  flex:0 0 26px;
}
.playIcon{font-size:22px}
.stopSquare{
  width:20px;   /* ‚úÖ bigger again */
  height:20px;  /* ‚úÖ bigger again */
  background:currentColor;
  border-radius:4px;
}

/* Row 2: playlist */
.row2{ flex-basis:100%; }
#playlist, #deleteBtn{ flex-basis:auto; }
#playlist{ min-width:320px; }

/* ======= STAGE / SVG ======= */
.stage{
  overflow:auto;
  margin-top:14px;
  -webkit-overflow-scrolling:touch;
  border-radius:16px;
  background:#fff;
  border:1px solid rgba(0,0,0,.06);
}

/* SVG styles (bigger) */
.staff{stroke:#111827;stroke-width:3;stroke-linecap:round}
.bar{stroke:#111827;stroke-width:3}
.noteHead{fill:#111827}
.stem{stroke:#111827;stroke-width:3;stroke-linecap:round}
.label{
  font:26px system-ui;
  font-weight:1000;
  text-anchor:middle;
}
.playhead{stroke:var(--accent);stroke-width:6;stroke-linecap:round}
.restGlyph{
  fill:#111827;
  text-anchor:middle;
  dominant-baseline:middle;
  font-family:
    "Bravura","Noto Music","Noto Music Symbols",
    "Segoe UI Symbol","Symbola","Arial Unicode MS",sans-serif;
  font-size:56px;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="card">

    <div class="controls">
      <!-- ROW 1 -->
      <button id="playBtn" class="primary">
        <span class="iconBox"><span class="playIcon">‚ñ∂</span></span>Play
      </button>

      <button id="stopBtn">
        <span class="iconBox"><span class="stopSquare"></span></span>Stop
      </button>

      <button id="clearBtn" class="danger">Clear</button>

      <span class="small">Tempo</span>
      <input id="tempo" type="range" min="60" max="160" value="96">
      <span id="tempoVal" class="small">96</span>

      <select id="bars">
        <option value="4" selected>4</option>
        <option value="8">8</option>
        <option value="16">16</option>
      </select>
      <span class="small">maten</span>

      <input id="songName" type="text" placeholder="Naam" autocomplete="off" />
      <button id="saveBtn">Save</button>
      <button id="exportBtn">Export</button>

      <button id="importBtn">Load</button>
      <input id="importFile" type="file" accept=".json,application/json" hidden>

      <!-- ROW 2 -->
      <span class="small row2">Playlist</span>
      <select id="playlist" class="row2"></select>
      <button id="deleteBtn" class="danger row2">Delete</button>
      <span id="status" class="small row2"></span>
    </div>

    <div class="stage" id="stage">
      <svg id="svg" width="1400" height="420"></svg>
    </div>

  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const NOTE_TO_MIDI = { C:60, D:62, E:64, F:65, G:67, A:69, B:71 };
const BW = {
  C:"#e11d48", D:"#f97316", E:"#facc15",
  F:"#8ed265", G:"#008a8c",
  A:"#7c3aed", B:"#ec4899"
};
const STORAGE_KEY="notenPlayer_playlist_v1";

/* staff (bigger) */
const STAFF_TOP=78, STAFF_LEFT=52, LINE_GAP=22, STAFF_LINES=5;

/* note spacing (bigger) */
const NOTE_GAP=92;
const NOTE_R=10;
const STEM_H=56;
const STEM_X_NUDGE=0.6;

/* scroll behavior */
const BEATS_PER_BAR=4;
const STEP_BARS=4;
const LEFT_PAD_FRAC=0.08;

/* note entry reveal (only scroll if needed) */
const ENTRY_RIGHT_GUARD=0.86;
const ENTRY_LEFT_GUARD=0.10;
const ENTRY_ANCHOR=0.70;

/* =========================
   STATE / DOM
========================= */
let SONG=[];
let bars=4;

const stage=document.getElementById("stage");
const svg=document.getElementById("svg");

const tempoEl=document.getElementById("tempo");
const tempoVal=document.getElementById("tempoVal");
const barsEl=document.getElementById("bars");

const playBtn=document.getElementById("playBtn");
const stopBtn=document.getElementById("stopBtn");
const clearBtn=document.getElementById("clearBtn");

const songNameEl=document.getElementById("songName");
const saveBtn=document.getElementById("saveBtn");
const exportBtn=document.getElementById("exportBtn");
const importBtn=document.getElementById("importBtn");
const importFile=document.getElementById("importFile");

const playlistEl=document.getElementById("playlist");
const deleteBtn=document.getElementById("deleteBtn");
const statusEl=document.getElementById("status");

function maxItems(){ return bars*4; }
function setStatus(msg){
  statusEl.textContent = msg || "";
  if(msg) setTimeout(()=>{ if(statusEl.textContent===msg) statusEl.textContent=""; }, 2200);
}

/* =========================
   AUDIO (melody + drums + count-in)
========================= */
let ctx=null, master=null;
let activeNodes=new Set();
const MASTER_LEVEL=0.38;
const DRUM_LEVEL=1.45;

function ensureAudio(){
  if(!ctx){
    ctx=new (window.AudioContext||window.webkitAudioContext)();
    master=ctx.createGain();
    master.gain.value=MASTER_LEVEL;
    master.connect(ctx.destination);
  }
  if(ctx.state==="suspended") ctx.resume();
}
function freq(m){return 440*Math.pow(2,(m-69)/12)}
function playTone(m,t,d){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="triangle";
  o.frequency.setValueAtTime(freq(m),t);

  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.9,t+.01);
  g.gain.exponentialRampToValueAtTime(.0001,t+d-.02);

  o.connect(g); g.connect(master);
  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+d);
}
function blip(m){
  ensureAudio();
  playTone(m,ctx.currentTime+.01,.18);
}

/* count-in click */
function clickAt(t,high){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="square";
  o.frequency.setValueAtTime(high?2200:1400,t);
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.24*DRUM_LEVEL,t+.002);
  g.gain.exponentialRampToValueAtTime(.0001,t+.045);
  o.connect(g); g.connect(master);

  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+.05);
}

/* drums */
function drumKick(t){
  const o=ctx.createOscillator(), g=ctx.createGain();
  o.type="sine";
  o.frequency.setValueAtTime(120,t);
  o.frequency.exponentialRampToValueAtTime(55,t+.08);

  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.60*DRUM_LEVEL,t+.004);
  g.gain.exponentialRampToValueAtTime(.0001,t+.12);

  o.connect(g); g.connect(master);
  activeNodes.add(o); activeNodes.add(g);
  o.onended=()=>{ activeNodes.delete(o); activeNodes.delete(g); };

  o.start(t); o.stop(t+.13);
}
function drumSnare(t){
  const noise=ctx.createBufferSource();
  const buf=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.12), ctx.sampleRate);
  const data=buf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
  noise.buffer=buf;

  const hp=ctx.createBiquadFilter();
  hp.type="highpass"; hp.frequency.setValueAtTime(1200,t);

  const g=ctx.createGain();
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.32*DRUM_LEVEL,t+.003);
  g.gain.exponentialRampToValueAtTime(.0001,t+.10);

  noise.connect(hp); hp.connect(g); g.connect(master);

  activeNodes.add(noise); activeNodes.add(hp); activeNodes.add(g);
  noise.onended=()=>{ activeNodes.delete(noise); activeNodes.delete(hp); activeNodes.delete(g); };

  noise.start(t); noise.stop(t+.11);
}
function drumHat(t){
  const noise=ctx.createBufferSource();
  const buf=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.03), ctx.sampleRate);
  const data=buf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
  noise.buffer=buf;

  const bp=ctx.createBiquadFilter();
  bp.type="bandpass"; bp.frequency.setValueAtTime(9000,t); bp.Q.setValueAtTime(6,t);

  const g=ctx.createGain();
  g.gain.setValueAtTime(.0001,t);
  g.gain.exponentialRampToValueAtTime(.14*DRUM_LEVEL,t+.0015);
  g.gain.exponentialRampToValueAtTime(.0001,t+.028);

  noise.connect(bp); bp.connect(g); g.connect(master);

  activeNodes.add(noise); activeNodes.add(bp); activeNodes.add(g);
  noise.onended=()=>{ activeNodes.delete(noise); activeNodes.delete(bp); activeNodes.delete(g); };

  noise.start(t); noise.stop(t+.03);
}
function scheduleDrums(startTime, beatDur, totalBeats){
  const totalHatSteps=totalBeats*2;
  for(let s=0;s<totalHatSteps;s++){
    const t=startTime + (s*(beatDur/2));
    drumHat(t);
  }
  for(let b=0;b<totalBeats;b++){
    const t=startTime + b*beatDur;
    const pos=b%4;
    if(pos===0 || pos===2) drumKick(t);
    if(pos===1 || pos===3) drumSnare(t);
  }
}

/* =========================
   PITCH ‚Üí Y
========================= */
function pcToLetter(pc){return [0,0,1,1,2,3,3,4,4,5,5,6][pc]}
function yPos(m){
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;
  const oct=Math.floor(m/12)-1;
  const abs=oct*7+pcToLetter(m%12);
  const ref=4*7+2; // C4-ish
  return bottom-(abs-ref)*(LINE_GAP/2);
}

/* =========================
   SVG helpers
========================= */
function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
function L(x1,y1,x2,y2,cls){
  const l=document.createElementNS("http://www.w3.org/2000/svg","line");
  l.setAttribute("x1",x1); l.setAttribute("y1",y1);
  l.setAttribute("x2",x2); l.setAttribute("y2",y2);
  if(cls) l.setAttribute("class",cls);
  return l;
}
function E(cx,cy,rx,ry,cls){
  const e=document.createElementNS("http://www.w3.org/2000/svg","ellipse");
  e.setAttribute("cx",cx); e.setAttribute("cy",cy);
  e.setAttribute("rx",rx); e.setAttribute("ry",ry);
  if(cls) e.setAttribute("class",cls);
  return e;
}
function T(x,y,txt,cls,fill){
  const t=document.createElementNS("http://www.w3.org/2000/svg","text");
  t.setAttribute("x",x); t.setAttribute("y",y);
  if(cls) t.setAttribute("class",cls);
  if(fill) t.setAttribute("fill",fill);
  t.textContent=txt;
  return t;
}

/* =========================
   SCROLL + PLAYHEAD
========================= */
let noteX=[], playhead=null;
let lastWindowStartBar=-1;

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function scrollToWindowStartBar(windowStartBar){
  const startIndex = windowStartBar * BEATS_PER_BAR;
  const x = noteX[startIndex] ?? STAFF_LEFT;

  const vw = Math.max(1, stage.clientWidth);
  const maxScroll = Math.max(0, stage.scrollWidth - stage.clientWidth);
  const target = x - vw*LEFT_PAD_FRAC;
  stage.scrollLeft = clamp(target, 0, maxScroll);
}

function updateWindowByIndex(i){
  const bar = Math.floor(i / BEATS_PER_BAR);
  const windowStartBar = Math.floor(bar / STEP_BARS) * STEP_BARS;

  if(windowStartBar !== lastWindowStartBar){
    lastWindowStartBar = windowStartBar;
    scrollToWindowStartBar(windowStartBar);
  }
}

function revealIndexIfNeeded(i){
  if(i<0 || i>=noteX.length) return;

  const x = noteX[i];
  const vw = Math.max(1, stage.clientWidth);
  const maxScroll = Math.max(0, stage.scrollWidth - stage.clientWidth);
  const left = stage.scrollLeft;

  const leftGuard  = left + vw*ENTRY_LEFT_GUARD;
  const rightGuard = left + vw*ENTRY_RIGHT_GUARD;

  if(x > rightGuard || x < leftGuard){
    const target = x - vw*ENTRY_ANCHOR;
    stage.scrollLeft = clamp(target, 0, maxScroll);
  }
}

function setPlayhead(i){
  if(!playhead || i<0 || i>=noteX.length){
    if(playhead) playhead.setAttribute("visibility","hidden");
    return;
  }
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;
  const x=noteX[i];
  playhead.setAttribute("x1",x);
  playhead.setAttribute("x2",x);
  playhead.setAttribute("y1",STAFF_TOP-36);
  playhead.setAttribute("y2",bottom+36);
  playhead.setAttribute("visibility","visible");

  if(isPlaying && (i % BEATS_PER_BAR === 0)){
    updateWindowByIndex(i);
  }
}

/* =========================
   RENDER
========================= */
function render(){
  clearSvg();
  noteX=[];
  const bottom=STAFF_TOP+(STAFF_LINES-1)*LINE_GAP;

  // staff lines
  for(let i=0;i<STAFF_LINES;i++){
    svg.appendChild(L(STAFF_LEFT, STAFF_TOP+i*LINE_GAP, 9000, STAFF_TOP+i*LINE_GAP, "staff"));
  }

  // playhead
  playhead = L(STAFF_LEFT, STAFF_TOP-36, STAFF_LEFT, bottom+36, "playhead");
  playhead.setAttribute("visibility","hidden");
  svg.appendChild(playhead);

  let x=STAFF_LEFT+44;
  let beats=0;

  SONG.forEach((it,i)=>{
    // bar line each 4 beats
    if(beats>0 && beats%4===0){
      svg.appendChild(L(x-18, STAFF_TOP, x-18, bottom, "bar"));
    }

    if(it.type==="note"){
      const y=yPos(it.pitch);

      // note head
      svg.appendChild(E(x, y, NOTE_R+2, NOTE_R, "noteHead"));

      // simple ledger line for C4 example (optional)
      if(it.pitch===60){
        svg.appendChild(L(x-22, y, x+22, y, "staff"));
      }

      // stem
      const sx=x+NOTE_R-STEM_X_NUDGE;
      svg.appendChild(L(sx, y, sx, y-STEM_H, "stem"));

      // note name (bigger + a bit higher)
      const n = Object.keys(NOTE_TO_MIDI).find(k => (NOTE_TO_MIDI[k]%12)===(it.pitch%12));
      svg.appendChild(T(x, bottom+60, n, "label", BW[n]||"#111827"));
    }else{
      // rest glyph
      svg.appendChild(T(x, STAFF_TOP+LINE_GAP*2, "ùÑΩ", "restGlyph"));
    }

    noteX[i]=x;
    beats++;
    x+=NOTE_GAP;
  });

  svg.setAttribute("width", Math.max(1400, x+80));
  svg.setAttribute("height", 420);
}

/* =========================
   PLAYBACK (loop until stop)
========================= */
let isPlaying=false, timers=[];
let spaceHeld=false;

function stop(){
  isPlaying=false;
  timers.forEach(clearTimeout); timers=[];
  setPlayhead(-1);
  lastWindowStartBar=-1;

  if(ctx && master){
    const now=ctx.currentTime;
    master.gain.setTargetAtTime(.0001,now,.01);
    activeNodes.forEach(n=>{
      try{ if(typeof n.stop==="function") n.stop(now); }catch{}
    });
    activeNodes.clear();
    setTimeout(()=>{ if(master) master.gain.value=MASTER_LEVEL; },40);
  }
}

function scheduleLoop(startTime){
  if(!isPlaying) return;

  const beat=60/tempoEl.value;
  let t=startTime;

  // drums for whole song
  scheduleDrums(t, beat, SONG.length);

  SONG.forEach((it,i)=>{
    if(it.type==="note") playTone(it.pitch,t,beat);
    timers.push(setTimeout(()=>{ if(isPlaying) setPlayhead(i); }, (t-ctx.currentTime)*1000));
    t+=beat;
  });

  // loop
  timers.push(setTimeout(()=>{
    if(isPlaying){
      stage.scrollLeft=0;
      lastWindowStartBar=-1;
      scheduleLoop(t);
    }
  }, (t-ctx.currentTime)*1000));
}

function play(){
  if(!SONG.length) return;

  ensureAudio();
  stop();
  isPlaying=true;

  const beat=60/tempoEl.value;
  let t=ctx.currentTime+.12;

  stage.scrollLeft=0;
  lastWindowStartBar=-1;

  // 1-bar count-in (4 beats)
  scheduleDrums(t, beat, 4);
  for(let i=0;i<4;i++) clickAt(t+i*beat, i===0);

  t += 4*beat;

  // show first window
  updateWindowByIndex(0);

  scheduleLoop(t);
}

/* =========================
   INPUT (notes + rest)
========================= */
function afterEditReveal(){
  if(playhead) playhead.setAttribute("visibility","hidden");
  revealIndexIfNeeded(SONG.length-1);
}

function addNote(n,hi){
  if(SONG.length>=maxItems()) return;
  const p=NOTE_TO_MIDI[n]+(hi?12:0);
  SONG.push({type:"note",pitch:p});
  render();
  afterEditReveal();
  blip(p); // ‚úÖ sound on entry
}
function addRest(){
  if(SONG.length>=maxItems()) return;
  SONG.push({type:"rest"});
  render();
  afterEditReveal();
}
function delLast(){
  SONG.pop();
  render();
  afterEditReveal();
}

function isTypingTarget(el){
  return el && (el.tagName==="INPUT" || el.tagName==="TEXTAREA" || el.isContentEditable);
}

function setPlayVisual(down){ playBtn.classList.toggle("kbdDown", down); }
function setStopVisual(down){ stopBtn.classList.toggle("kbdDown", down); }

window.addEventListener("keydown",(e)=>{
  if(isTypingTarget(document.activeElement)){
    if(e.code==="Escape"){ e.preventDefault(); stop(); }
    return;
  }

  if(e.code==="Space"){
    e.preventDefault();
    if(!spaceHeld){
      spaceHeld=true;
      if(isPlaying){
        setStopVisual(true);
        stop();
        setTimeout(()=>setStopVisual(false), 140);
      }else{
        setPlayVisual(true);
        play();
        setTimeout(()=>setPlayVisual(false), 140);
      }
    }
    return;
  }

  if(e.key==="Backspace"){ e.preventDefault(); delLast(); return; }
  if(e.key==="/"){ addRest(); return; }

  const k=e.key.toUpperCase();
  if(NOTE_TO_MIDI[k]) addNote(k, e.shiftKey);
},{passive:false});

window.addEventListener("keyup",(e)=>{
  if(e.code==="Space"){
    spaceHeld=false;
    setPlayVisual(false);
    setStopVisual(false);
  }
});

/* =========================
   PLAYLIST (autosave in localStorage)
========================= */
function readPlaylist(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    const arr=raw?JSON.parse(raw):[];
    return Array.isArray(arr)?arr:[];
  }catch{ return []; }
}
function writePlaylist(arr){ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
function refreshPlaylistUI(selectName=null){
  const list=readPlaylist().sort((a,b)=>a.name.localeCompare(b.name));
  playlistEl.innerHTML="";
  if(!list.length){
    const opt=document.createElement("option");
    opt.value=""; opt.textContent="(leeg)";
    playlistEl.appendChild(opt);
    return;
  }
  list.forEach(item=>{
    const opt=document.createElement("option");
    opt.value=item.name;
    opt.textContent=item.name;
    playlistEl.appendChild(opt);
  });
  if(selectName){
    const found=[...playlistEl.options].some(o=>o.value===selectName);
    if(found) playlistEl.value=selectName;
  }
}

function saveCurrent(){
  const name=(songNameEl.value||"").trim();
  if(!name){ setStatus("Geef een naam."); songNameEl.focus(); return; }
  const entry={ name, bars, song: SONG.slice(0, maxItems()) };
  const list=readPlaylist();
  const idx=list.findIndex(x=>x.name===name);
  if(idx>=0) list[idx]=entry; else list.push(entry);
  writePlaylist(list);
  refreshPlaylistUI(name);
  setStatus("Saved ‚úÖ");
}

function loadByName(name){
  const list=readPlaylist();
  const item=list.find(x=>x.name===name);
  if(!item) return;

  stop();
  bars=item.bars||4;
  barsEl.value=String(bars);

  SONG=Array.isArray(item.song) ? item.song.slice(0, bars*4) : [];
  songNameEl.value=item.name||"";

  render();
  stage.scrollLeft=0;
  setStatus("Loaded ‚úÖ");
}

function deleteSelected(){
  const name=playlistEl.value;
  if(!name) return;
  const list=readPlaylist().filter(x=>x.name!==name);
  writePlaylist(list);
  refreshPlaylistUI();
  setStatus("Deleted üóëÔ∏è");
}

/* =========================
   EXPORT / LOAD FILE
========================= */
function safeFileName(s){
  return (s||"song").trim().replace(/[\\\/:*?"<>|]+/g,"-").slice(0,80) || "song";
}
function exportCurrent(){
  const name=(songNameEl.value||"").trim() || "song";
  const payload={app:"noten-player",version:1,name,bars,tempo:+tempoEl.value,song:SONG.slice(0, maxItems())};
  const blob=new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download=`${safeFileName(name)}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 400);
  setStatus("Exported ‚¨áÔ∏è");
}
function importFromObject(obj){
  if(!obj || typeof obj!=="object") throw new Error("Ongeldig bestand.");
  if(!Array.isArray(obj.song)) throw new Error("Geen song gevonden.");
  const newBars=(obj.bars===4||obj.bars===8||obj.bars===16)?obj.bars:4;

  stop();
  bars=newBars;
  barsEl.value=String(bars);

  SONG=obj.song.slice(0,bars*4).map(it=>{
    if(it && it.type==="rest") return {type:"rest"};
    if(it && it.type==="note" && Number.isFinite(it.pitch)) return {type:"note",pitch:+it.pitch};
    return null;
  }).filter(Boolean);

  if(typeof obj.name==="string") songNameEl.value=obj.name.trim();
  if(Number.isFinite(obj.tempo)){
    const t=Math.max(+tempoEl.min, Math.min(+tempoEl.max, +obj.tempo));
    tempoEl.value=String(t); tempoVal.textContent=String(t);
  }

  render();
  stage.scrollLeft=0;
  setStatus("Loaded ‚úÖ");
}
function handleImportFile(file){
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{ importFromObject(JSON.parse(String(reader.result||""))); }
    catch{ setStatus("Load mislukt."); }
    importFile.value="";
  };
  reader.readAsText(file);
}

/* =========================
   UI wiring
========================= */
tempoVal.textContent=tempoEl.value;
tempoEl.oninput=()=>tempoVal.textContent=tempoEl.value;

barsEl.value=String(bars);
barsEl.onchange=()=>{
  bars=+barsEl.value;
  if(SONG.length>maxItems()) SONG=SONG.slice(0,maxItems());
  render();
  afterEditReveal();
};

playBtn.onclick=()=>{
  setPlayVisual(true);
  play();
  setTimeout(()=>setPlayVisual(false), 140);
};
stopBtn.onclick=()=>{
  setStopVisual(true);
  stop();
  setTimeout(()=>setStopVisual(false), 140);
};
clearBtn.onclick=()=>{
  stop();
  SONG=[];
  render();
  stage.scrollLeft=0;
  setStatus("Cleared");
};

saveBtn.onclick=saveCurrent;
exportBtn.onclick=exportCurrent;

importBtn.onclick=()=>importFile.click();
importFile.onchange=()=>handleImportFile(importFile.files && importFile.files[0]);

deleteBtn.onclick=deleteSelected;

songNameEl.addEventListener("keydown",(e)=>{
  if(e.key==="Enter"){ e.preventDefault(); saveCurrent(); }
});

playlistEl.onchange=()=>{
  const name=playlistEl.value;
  if(name) loadByName(name); // ‚úÖ no load button needed
};

window.addEventListener("resize", ()=>{
  if(isPlaying && lastWindowStartBar>=0){
    scrollToWindowStartBar(lastWindowStartBar);
  }else{
    revealIndexIfNeeded(SONG.length-1);
  }
});

refreshPlaylistUI();
render();
</script>
</body>
</html>
